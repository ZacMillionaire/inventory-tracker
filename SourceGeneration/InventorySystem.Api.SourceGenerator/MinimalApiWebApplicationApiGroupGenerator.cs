using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace InventorySystem.Api.SourceGenerator;

internal static class SourceGenerationHelper
{
	public const string Namespace = "InventorySystem.Core.Api";

	private const string _header = $"""
	                                //------------------------------------------------------------------------------
	                                // <auto-generated>
	                                //     This code was generated by the {Namespace} source generator
	                                //
	                                //     Changes to this file may cause incorrect behavior and will be lost if
	                                //     the code is regenerated.
	                                // </auto-generated>
	                                //------------------------------------------------------------------------------
	                                #nullable enable
	                                """;

	public const string ApiGroupAttribute =
		$$"""
		  {{_header}}
		  namespace {{Namespace}}
		  {
		      [System.AttributeUsage(System.AttributeTargets.Class)]
		      internal class ApiGroupAttribute : System.Attribute
		      {
		  		public ApiGroupAttribute(string route)
		  		{
		  		}
		      }
		      
		      [System.AttributeUsage(System.AttributeTargets.Method)]
		      internal class ApiGetAttribute : System.Attribute
		      {
		  		public string Route { get; set; }
		  		public ApiGetAttribute(string route)
		  		{
		  			Route = route;
		  		}
		      }
		      
		      [System.AttributeUsage(System.AttributeTargets.Method)]
		      internal class ApiPostAttribute : System.Attribute
		      {
		  		public ApiPostAttribute(string route)
		  		{
		  		}
		      }
		  }
		  """;
}

[Generator]
internal class MinimalApiWebApplicationApiGroupGenerator : IIncrementalGenerator
{
	private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
		=> node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"ApiGroupAttribute.g.cs",
			SourceText.From(SourceGenerationHelper.ApiGroupAttribute, Encoding.UTF8)));

		var a = context.SyntaxProvider.ForAttributeWithMetadataName($"{SourceGenerationHelper.Namespace}.ApiGroupAttribute",
				predicate: static (s, _) => true,
				transform: static (ctx, _) => GetApiGroupToGenerate(ctx.SemanticModel, ctx.TargetNode))
			.Where(static x => x is not null);

		context.RegisterSourceOutput(a,
			static (spc, source) => Execute(source, spc));
	}

	static void Execute(ApiGroup? apiGroupToGenerate, SourceProductionContext context)
	{
		if (apiGroupToGenerate is { } value)
		{
			// TODO: look at making a generator that takes a class (with attributes), and generates a partial from it that calls into the instances
			//  maybe? Not sure on the performance there but whatever
			var sb = new StringBuilder();
			sb.AppendLine("using Microsoft.AspNetCore.Builder;");
			sb.AppendLine($"using {value.Namespace};");
			sb.AppendLine("public static partial class WebApplicationExtensions");
			sb.AppendLine("{");
			sb.AppendLine("	extension(WebApplication app)");
			sb.AppendLine("	{");
			sb.AppendLine($"		public void With{value.Name}()");
			sb.AppendLine("		{");
			sb.AppendLine($"			var apiGroup = app.MapGroup(\"/{value.Route}\");");
			foreach (var valueRoute in value.Routes)
			{
				sb.AppendLine($"			apiGroup.Map{ApiMethodTypeToString(valueRoute.Type)}(\"{valueRoute.Route}\", {value.Name}.{valueRoute.Name})");
				sb.AppendLine($"				.WithName(\"{valueRoute.Name}\");");
			}

			sb.AppendLine("		}");
			sb.AppendLine("	}");
			sb.Append("}");
			context.AddSource($"{value.Name}.Api.g.cs", sb.ToString());
		}
	}

	static ApiGroup? GetApiGroupToGenerate(SemanticModel semanticModel, SyntaxNode enumDeclarationSyntax)
	{
		if (semanticModel.GetDeclaredSymbol(enumDeclarationSyntax) is not INamedTypeSymbol classSymbol)
		{
			// something went wrong
			return null;
		}

		// Get the group to build the api group map
		var group = ParseGroupAttribute(classSymbol);

		var classMethods = classSymbol.GetMembers()
			.Where(x => x is IMethodSymbol method
			            && method.GetAttributes() is { Length: > 0 } attributes);

		foreach (var classMethod in classMethods)
		{
			if (ParseApiMethodAttribute(classMethod) is { } routeAttribute)
			{
				group.Routes.Add(routeAttribute);
			}
		}

		return group;
	}

	static ApiRoute? ParseApiMethodAttribute(ISymbol classMethod)
	{
		var attributeData = classMethod.GetAttributes().FirstOrDefault(x =>
			x.AttributeClass is { } attributeClass
			&& attributeClass.ContainingNamespace.ToDisplayString() == $"{SourceGenerationHelper.Namespace}");


		if (attributeData is not { AttributeClass: not null } routeAttribute)
		{
			return null;
		}

		var method = routeAttribute.AttributeClass.Name switch
		{
			"ApiGetAttribute" => ApiMethods.Get,
			"ApiPostAttribute" => ApiMethods.Post,
			_ => ApiMethods.Unknown
		};

		if (routeAttribute.ConstructorArguments.IsEmpty == false)
		{
			return new ApiRoute(routeAttribute.ConstructorArguments[0].Value as string ?? classMethod.Name, classMethod.Name, method);
		}

		// If there's no constructor argument, the name of the route is the name of the class
		// TODO: test this
		return new ApiRoute(classMethod.Name, classMethod.Name, method);
	}

	static ApiGroup ParseGroupAttribute(INamedTypeSymbol classSymbol)
	{
		var attributeData = classSymbol.GetAttributes()
			.FirstOrDefault(x => x.AttributeClass is { } attributeClass
			                     && attributeClass.ContainingNamespace.ToDisplayString() == $"{SourceGenerationHelper.Namespace}"
			                     && attributeClass.Name == "ApiGroupAttribute");

		// This is the namespace of the class that has the static methods that will be called
		var apiClassNamespace = classSymbol.ContainingNamespace.ToDisplayString();

		if (attributeData is { ConstructorArguments.IsEmpty: false } groupAttribute)
		{
			return new ApiGroup(groupAttribute.ConstructorArguments[0].Value as string ?? classSymbol.Name, classSymbol.Name, apiClassNamespace);
		}

		// If there's no constructor argument, the name of the route is the name of the class
		// TODO: test this
		return new ApiGroup(classSymbol.Name, classSymbol.Name, apiClassNamespace);
	}

	private enum ApiMethods
	{
		Unknown,
		Get,
		Post,
	}

	private readonly record struct ApiGroup
	{
		public string Route { get; }
		public string Name { get; }
		public string Namespace { get; }
		public List<ApiRoute> Routes { get; }

		public ApiGroup(string route, string name, string @namespace)
		{
			Name = name;
			Route = route;
			Namespace = @namespace;
			Routes = [];
		}
	}

	private readonly record struct ApiRoute
	{
		public string Route { get; }
		public string Name { get; }
		public ApiMethods Type { get; }

		public ApiRoute(string route, string name, ApiMethods type)
		{
			Route = route;
			Name = name;
			Type = type;
		}
	}

	private static string ApiMethodTypeToString(ApiMethods type)
	{
		switch (type)
		{
			case ApiMethods.Get:
				return "Get";
			case ApiMethods.Post:
				return "Post";
			// Anything currently unmapped maps to Get
			// TODO: test this maybe
			default:
				return "Get";
		}
	}
}